*cmdbuf.nvim.txt*

==============================================================================
Lua module: cmdbuf                                        *cmdbuf.nvim-cmdbuf*

open({opts})                                                   *cmdbuf.open()*
  Open a command buffer.

  Parameters: ~
    {opts} (table|nil) |cmdbuf.nvim-open-opts|

split_open({height}, {opts})                             *cmdbuf.split_open()*
  Open a command buffer with `split`.

  Parameters: ~
    {height} (number|nil) window height
    {opts} (table|nil) |cmdbuf.nvim-open-opts|

vsplit_open({width}, {opts})                            *cmdbuf.vsplit_open()*
  Open a command buffer with `vsplit`.

  Parameters: ~
    {width} (number|nil) window width
    {opts} (table|nil) |cmdbuf.nvim-open-opts|

tab_open({opts})                                           *cmdbuf.tab_open()*
  Open a command buffer in new tab.

  Parameters: ~
    {opts} (table|nil) |cmdbuf.nvim-open-opts|

execute({opts})                                             *cmdbuf.execute()*
  Execute the current line command.

  Parameters: ~
    {opts} (table|nil) |cmdbuf.nvim-open-opts|

delete({range})                                              *cmdbuf.delete()*
  Delete current line (or given range) from command history

  Parameters: ~
    {range} (table|nil) 1-based range {start number, end number}

==============================================================================
OPTIONS                                                  *cmdbuf.nvim-OPTIONS*

|cmdbuf.open()| options                                *cmdbuf.nvim-open-opts*

- {column} (number | nil): initial cursor column in the buffer.
- {line} (number | nil): set this string to the bottom line in the buffer.
- {reusable_window_ids} (list | nil): force to reuse the window that has the same buffer name. (default: {})
- {type} (string | nil): handler type (default = "vim/cmd")
  - `vim/cmd`: |q:| alternative
  - `vim/sesarch/forward`: |q/| alternative
  - `vim/sesarch/backward`: |q?| alternative
  - `lua/cmd`: |q:| alternative for lua command
  - `lua/variable/buffer`: buffer variable and command

|cmdbuf.execute()| options                          *cmdbuf.nvim-execute-opts*

- {quit} (boolean | nil): whether quit the window after execution.

==============================================================================
AUTOCOMMANDS                                        *cmdbuf.nvim-AUTOCOMMANDS*

CmdbufNew                                              *cmdbuf.nvim-CmdbufNew*
  This is fired after creating a new cmdbuf.

==============================================================================
EXAMPLES                                                *cmdbuf.nvim-EXAMPLES*

>lua
  vim.keymap.set("n", "q:", function()
    require("cmdbuf").split_open(vim.o.cmdwinheight)
  end)
  vim.keymap.set("c", "<C-f>", function()
    require("cmdbuf").split_open(vim.o.cmdwinheight, { line = vim.fn.getcmdline(), column = vim.fn.getcmdpos() })
    vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<C-c>", true, false, true), "n", true)
  end)

  -- Custom buffer mappings
  vim.api.nvim_create_autocmd({ "User" }, {
    group = vim.api.nvim_create_augroup("cmdbuf_setting", {}),
    pattern = { "CmdbufNew" },
    callback = function()
      vim.keymap.set("n", "q", [[<Cmd>quit<CR>]], { nowait = true, buffer = true })
      vim.keymap.set("n", "dd", [[<Cmd>lua require('cmdbuf').delete()<CR>]], { buffer = true })
    end,
  })

  -- open lua command-line window
  vim.keymap.set("n", "ql", function()
    require("cmdbuf").split_open(vim.o.cmdwinheight, { type = "lua/cmd" })
  end)

  -- q/, q? alternative
  vim.keymap.set("n", "q/", function()
    require("cmdbuf").split_open(vim.o.cmdwinheight, { type = "vim/search/forward" })
  end)
  vim.keymap.set("n", "q?", function()
    require("cmdbuf").split_open(vim.o.cmdwinheight, { type = "vim/search/backward" })
  end)
<

==============================================================================
vim:tw=78:ts=8:ft=help
